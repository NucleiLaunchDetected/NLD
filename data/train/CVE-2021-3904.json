[
    {
        "cve_id": "CVE-2021-3904",
        "code_before_change": "public static function detectXss($string, array $options = null): ?string\n{\n\t// Skip any null or non string values\n\tif (null === $string || !is_string($string) || empty($string)) {\n\t\treturn null;\n\t}\n\n\tif (null === $options) {\n\t\t$options = static::getXssDefaults();\n\t}\n\n\t$enabled_rules = (array)($options['enabled_rules'] ?? null);\n\t$dangerous_tags = (array)($options['dangerous_tags'] ?? null);\n\tif (!$dangerous_tags) {\n\t\t$enabled_rules['dangerous_tags'] = false;\n\t}\n\t$invalid_protocols = (array)($options['invalid_protocols'] ?? null);\n\tif (!$invalid_protocols) {\n\t\t$enabled_rules['invalid_protocols'] = false;\n\t}\n\t$enabled_rules = array_filter($enabled_rules, static function ($val) { return !empty($val); });\n\tif (!$enabled_rules) {\n\t\treturn null;\n\t}\n\n\t// Keep a copy of the original string before cleaning up\n\t$orig = $string;\n\t\n\t// URL decode\n\t$string = urldecode($string);\n\n\t// Convert Hexadecimals\n\t$string = (string)preg_replace_callback('!(&#|\\\\)[xX]([0-9a-fA-F]+);?!u', static function ($m) {\n\t\treturn chr(hexdec($m[2]));\n\t}, $string);\n\n\t// Clean up entities\n\t$string = preg_replace('!(&#0+[0-9]+)!u', '$1;', $string);\n\n\t// Decode entities\n\t$string = html_entity_decode($string, ENT_NOQUOTES, 'UTF-8');\n\n\t// Strip whitespace characters\n\t$string = preg_replace('!\\s!u', '', $string);\n\n\t// Set the patterns we'll test against\n\t$patterns = [\n\t\t// Match any attribute starting with \"on\" or xmlns\n\t\t'on_events' => '#(<[^>]+[[a-z\\x00-\\x20\\\"\\'\\/])([\\s\\/]on|\\sxmlns)[a-z].*=>?#iUu',\n\n\t\t// Match javascript:, livescript:, vbscript:, mocha:, feed: and data: protocols\n\t\t'invalid_protocols' => '#(' . implode('|', array_map('preg_quote', $invalid_protocols, ['#'])) . '):\\S.*?#iUu',\n\n\t\t// Match -moz-bindings\n\t\t'moz_binding' => '#-moz-binding[a-z\\x00-\\x20]*:#u',\n\n\t\t// Match style attributes\n\t\t'html_inline_styles' => '#(<[^>]+[a-z\\x00-\\x20\\\"\\'\\/])(style=[^>]*(url\\:|x\\:expression).*)>?#iUu',\n\t\t\n\t\t// Match potentially dangerous tags\n\t\t'dangerous_tags' => '#</*(' . implode('|', array_map('preg_quote', $dangerous_tags, ['#'])) . ')[^>]*>?#ui'\n\t];\n\n\t// Iterate over rules and return label if fail\n\tforeach ($patterns as $name => $regex) {\n\t\tif (!empty($enabled_rules[$name])) {\n\t\t\tif (preg_match($regex, $string) || preg_match($regex, $orig)) {\n\t\t\t\treturn $name;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}",
        "code_after_change": "public static function detectXss($string, array $options = null): ?string\n{\n\t// Skip any null or non string values\n\tif (null === $string || !is_string($string) || empty($string)) {\n\t\treturn null;\n\t}\n\n\tif (null === $options) {\n\t\t$options = static::getXssDefaults();\n\t}\n\n\t$enabled_rules = (array)($options['enabled_rules'] ?? null);\n\t$dangerous_tags = (array)($options['dangerous_tags'] ?? null);\n\tif (!$dangerous_tags) {\n\t\t$enabled_rules['dangerous_tags'] = false;\n\t}\n\t$invalid_protocols = (array)($options['invalid_protocols'] ?? null);\n\tif (!$invalid_protocols) {\n\t\t$enabled_rules['invalid_protocols'] = false;\n\t}\n\t$enabled_rules = array_filter($enabled_rules, static function ($val) { return !empty($val); });\n\tif (!$enabled_rules) {\n\t\treturn null;\n\t}\n\n\t// Keep a copy of the original string before cleaning up\n\t$orig = $string;\n\t\n\t// URL decode\n\t$string = urldecode($string);\n\n\t// Convert Hexadecimals\n\t$string = (string)preg_replace_callback('!(&#|\\\\)[xX]([0-9a-fA-F]+);?!u', static function ($m) {\n\t\treturn chr(hexdec($m[2]));\n\t}, $string);\n\n\t// Clean up entities\n\t$string = preg_replace('!(&#0+[0-9]+)!u', '$1;', $string);\n\n\t// Decode entities\n\t$string = html_entity_decode($string, ENT_NOQUOTES | ENT_HTML5, 'UTF-8');\n\n\t// Strip whitespace characters\n\t$string = preg_replace('!\\s!u', '', $string);\n\n\t// Set the patterns we'll test against\n\t$patterns = [\n\t\t// Match any attribute starting with \"on\" or xmlns\n\t\t'on_events' => '#(<[^>]+[[a-z\\x00-\\x20\\\"\\'\\/])([\\s\\/]on|\\sxmlns)[a-z].*=>?#iUu',\n\n\t\t// Match javascript:, livescript:, vbscript:, mocha:, feed: and data: protocols\n\t\t'invalid_protocols' => '#(' . implode('|', array_map('preg_quote', $invalid_protocols, ['#'])) . '):\\S.*?#iUu',\n\n\t\t// Match -moz-bindings\n\t\t'moz_binding' => '#-moz-binding[a-z\\x00-\\x20]*:#u',\n\n\t\t// Match style attributes\n\t\t'html_inline_styles' => '#(<[^>]+[a-z\\x00-\\x20\\\"\\'\\/])(style=[^>]*(url\\:|x\\:expression).*)>?#iUu',\n\t\t\n\t\t// Match potentially dangerous tags\n\t\t'dangerous_tags' => '#</*(' . implode('|', array_map('preg_quote', $dangerous_tags, ['#'])) . ')[^>]*>?#ui'\n\t];\n\n\t// Iterate over rules and return label if fail\n\tforeach ($patterns as $name => $regex) {\n\t\tif (!empty($enabled_rules[$name])) {\n\t\t\tif (preg_match($regex, $string) || preg_match($regex, $orig)) {\n\t\t\t\treturn $name;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}",
        "patch": "--- code before\n+++ code after\n@@ -36,7 +36,8 @@\n\t\t{% endif %}\n\t\t{% for group in groups.index %}\n-\t\t{% set optionsList = optionsList|merge([{ text: group.readableName ?? group.groupname, value: group.groupname }]) %}\n+\t\t{# Security: Escape HTML in group names to prevent XSS (GHSA-rmw5-f87r-w988) #}\n+\t\t{% set optionsList = optionsList|merge([{ text: (group.readableName ?? group.groupname)|e, value: group.groupname }]) %}\n\t\t{% endfor %}\n\t{% endif %}",
        "function_modified_lines": {
            "added": [
                "\t$string = html_entity_decode($string, ENT_NOQUOTES | ENT_HTML5, 'UTF-8');"
            ],
            "deleted": [
                "\t$string = html_entity_decode($string, ENT_NOQUOTES, 'UTF-8');"
            ]
        },
        "cwe": [
            "CWE-79"
        ],
        "cve_description": "grav is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "id": 1
    }
]